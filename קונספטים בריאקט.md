# 🚀 React Hooks:
ריאקט Hooks הם פונקציות שמאפשרות לנו להשתמש בתכונות פנימיות של רכיבים פונקציונליים, במקום רק רכיבים ממשקיים. זה מאפשר לנו לשתף פעולה קלה יותר עם המחזיק הפנימי של הרכיב ולנהל את המצב ציד תגובה. הנה כמה מה-Hooks הנפוצים ביותר:

- [x] 1. **useState:** מאפשר לנו להוסיף מצב מקומי לרכיב. זה מאפשר לנו לשמור ערך ספציפי ולעדכן אותו בתגובה לפעולות משתמש.

- [x] 2. **useEffect:** מאפשר לנו להשתמש בפעולות ציד תגובה ברכיב, כגון ביצוע שאילתות רשת, הרשמה לאירועי DOM, או כל פעולה אחרת שדורשת ניהול חיי מחזיק רכיב.

- [x] 3. **useContext:** מאפשר לנו להעביר ערך מתחום רחב יותר של המידע של הרכיב, באופן דרסטי יותר מאשר שימוש ב-props.

- [x] 4. **useReducer:** ניתן להשתמש ב-Hooks זה כדי לנהל מצב מורכב יותר, בדומה לשימוש ב-Redux, תוך כדי עדכונים משובצים ברכיב.

- [x] 5. **useCallback ו- useMemo:** השימוש בשני ה-Hooks האלו עוזר למנוע רנדומליות ומאמצים מיותרים על ידי חידוש התגובה של פונקציות או ערכים רק כאשר הם משתנים באמת.




# 🥇 Redux:

ספרייה לניהול מצב באפליקציות React גדולות ומורכבות. הוא מבוסס על עקרון של נקודת אמת חד מקומית, ומשמש לניהול המצב של כל האפליקציה ממקום אחד. זה מקל על האפליקציה והופך אותה לפחות מורכבת ויותר קלה לתחזוקה ולניהול.

Redux מכיל ארבעה עקרונות יסודיים:

1. **מצב יחיד של האפליקציה:** המצב של כל האפליקציה מאוחסן באובייקט יחיד באחסון Redux.

2. **קריאה ועדכון נתונים רק דרך פעולות מוגדרות מראש:** לא ניתן לעדכן את המצב באופן ישיר, רק דרך "פעולות" מיוחדות.

3. **חוקי הוכחה:** ההחלטות והשינויים במצב מתבצעים על פי חוקי הוכחה מוגדרים מראש.

4. **שימוש ב-Redux-Store כאחסון עקבי ובריא:** זהו המקום היחידי בו מאוחסנים הנתונים והמצב של האפליקציה, והוא מאוחסן במקום אחד בלבד.

עבודה עם Redux משתלבת היטב עם React באמצעות שימוש ב-Hooks, כמו `useSelector` ו-`useDispatch`, שמאפשרים קריאה לסטאט של Redux ושליחת פעולות לאירועים, בהתאמה.



---
<br>


## 🔎 React Hooks Examples:

1. **useState:**
   ```javascript
   import React, { useState } from 'react';

   function Counter() {
       const [count, setCount] = useState(0);

       return (
           <div>
               <p>Count: {count}</p>
               <button onClick={() => setCount(count + 1)}>Increment</button>
           </div>
       );
   }
   ```

2. **useEffect:**
   ```javascript
   import React, { useState, useEffect } from 'react';

   function Timer() {
       const [seconds, setSeconds] = useState(0);

       useEffect(() => {
           const interval = setInterval(() => {
               setSeconds(seconds => seconds + 1);
           }, 1000);
           return () => clearInterval(interval);
       }, []);

       return <p>Timer: {seconds} seconds</p>;
   }
   ```

3. **useContext:**
   ```javascript
   import React, { useContext } from 'react';

   const ThemeContext = React.createContext('light');

   function ThemedButton() {
       const theme = useContext(ThemeContext);
       return <button style={{ background: theme }}>Themed Button</button>;
   }
   ```

   

## 🔎 Redux Examples:

1. **Redux Store Configuration:**
   ```javascript
   import { createStore } from 'redux';
   import rootReducer from './reducers';

   const store = createStore(rootReducer);
   ```

2. **Redux Actions:**
   ```javascript
   // action types
   const INCREMENT = 'INCREMENT';

   // action creators
   function increment() {
       return { type: INCREMENT };
   }
   ```

3. **Redux Reducers:**
   ```javascript
   const initialState = {
       count: 0
   };

   function counterReducer(state = initialState, action) {
       switch (action.type) {
           case INCREMENT:
               return { ...state, count: state.count + 1 };
           default:
               return state;
       }
   }
   ```

4. **Connecting Redux with React Component:**
   ```javascript
   import React from 'react';
   import { useSelector, useDispatch } from 'react-redux';
   import { increment } from './actions';

   function Counter() {
       const count = useSelector(state => state.count);
       const dispatch = useDispatch();

       return (
           <div>
               <p>Count: {count}</p>
               <button onClick={() => dispatch(increment())}>Increment</button>
           </div>
       );
   }
   ```

---


## 🚀 ידע כללי בריאקט:

### מה זה React?
**ספריית JavaScript בקוד פתוח** המשמשת לבניית UI הניתנים להרכבה, במיוחד עבור אפליקציות עמוד בודד (SPA).


### מהן התכונות העיקריות של React?
- שימוש בJSX, המאפשרת למפתחים לכתוב HTML בקוד ה-JS שלהם.
- שימוש ב-Virtual DOM במקום ב-Real DOM בהתחשב בכך שמניפולציות של Real DOM הן יקרות.
- תומך בעיבוד בצד השרת, שימושי עבור אופטימיזציות למנועי חיפוש (SEO).
- עוקב אחר זרימת נתונים חד כיוונית או חד כיוונית או data binding.
- משתמש ברכיבי UI ניתנים לשימוש חוזר/לחיבור לפיתוח התצוגה.

### מה זה JSX?
מייצג JavaScript XML. בדוגמה, הטקסט בתג `<h1>` מוחזר כפונקציית JavaScript לפונקציית העיבוד.
```jsx
export default function App() {
  return (
      <h1 className="greeting">{"Hello, this is a JSX Code!"}</h1>
  );
}
```
     
 ### שוני בין אלמנט לקומפוננטה:
 The JavaScript representation(Without JSX) of React Element would be as follows:
```javascript
    const element = React.createElement("div", { id: "login-btn" }, "Login");
```
and this element can be simiplified using JSX:

```html
      <div id="login-btn">Login</div>
```
The above React.createElement() function returns an object as below:
```javascript
{
  type: 'div',
  props: {
    children: 'Login',
    id: 'login-btn'
  }
}
```
לבסוף, אלמנט זה מעבד ל-DOM באמצעות ReactDOM.render().

אפשר להגדיר קומפוננטה בכמה צורות, יכול להיות כקלאס עם מתודת render() או פונקציה. בכל מקרה, הוא לוקח פרופס כקלט, ומחזיר עץ JSX כפלטט.

## מה זה סטייט ופרופס
- סטייט של קומפוננטה הוא אובייקט שמחזיק מידע מסוים שעשוי להשתנות במהלך חיי הקומפוננטה. בכל פעם שהסטייט משתנה, הקומפוננטה עושה עיבור מחדש. 
- פרופס זה קלט לקומפוננטה. הם ערכים בודדים או אובייקטים המכילים קבוצה של ערכים המועברים לקומפוננטה בעת היצירה בדומה לתכונות HTML-tag. כאן, הנתונים מועברים מרכיב הורה לרכיב בן.

המטרה העיקרית היא: העברת דאטה מותאם אישית לרכיב,טריגר שינויים בסטייט.
לדוגמה:
```jsx
      import React from "react";
      import ReactDOM from "react-dom";

      const ChildComponent = (props) => {
        return (
          <div>
            <p>{props.name}</p>
            <p>{props.age}</p>
            <p>{props.gender}</p>
          </div>
        );
      };

      const ParentComponent = () => {
        return (
          <div>
            <ChildComponent name="John" age="30" gender="male" />
            <ChildComponent name="Mary" age="25" geneder="female"/>
          </div>
        );
      };
```
ניתן גם לגשת ישירות לאובייקטים של הפרופס עם destructing:
```jsx
  const ChildComponent = ({name, age, gender="male"}) => {
      return (
        <div>
          <p>{name}</p>
          <p>{age}</p>
          <p>{gender}</p>
        </div>
      );
    };
```

## הבדל בין סטייט לפרופס:
- הסטייט מנוהל בקומפוננטה, ומעודכן עם 'useState', שינויים בסטייט גם מטרגטים רינדור של הקומפוננטה והילדים שלה.
- פרופס מועברים לקומפוננטה מקומפוננטת הורה, והם לקריאה בלבד, כלומר לא ניתן לערוך אותם בקומפוננטה עצמה.
- סטייט הוא mutable (ניתן לשינוי), פרופס הם immutable.


## ההבדל בין HTML ל-React event handling?
- בHTML באות קטנה:
```html
       <button onclick="activateLasers()"></button>
```

- בריאקט באותו גדולה:
```jsx harmony
       <button onClick={activateLasers}>
```
  - בHTML אפשר להחזיר FALSE כדי למנוע התנהגות דיפולטיבית:
```html
       <a
         href="#"
         onclick='console.log("The link was clicked."); return false;'
       />
```
  - בריאקט נצטרך לקרוא ל- preventDefault():
```javascript
       function handleClick(event) {
         event.preventDefault();
         console.log("The link was clicked.");
       }
```

## מה הוא הkey prop שמשתמשים בו בlist?
הפרופ הזה עוזר לריאקט לזהות איזה פריט השתנה. הוא צריך להיות ייחודי, בין האחים שלו. בדר"כ ניקח את הID מהדאטה. עוזר לקבוע איזה קומפוננטה צריכה רנדור, במקום לרנדר את כולן - שיפור ביצועים.
```jsx harmony
    const todoItems = todos.map((todo) => <li key={todo.id}>{todo.text}</li>);
```

##  Virtual DOM
קיצור של Document Object Model. ה-DOM מייצג מסמך HTML עם מבנה עץ לוגי. כל ענף של העץ מסתיים בצומת, וכל צומת מכיל אובייקטים.
ריאקט שומרת ייצוג קל של ה-DOM האמיתי בזיכרון, ידוע בתור DOM וירטואלי. כאשר הסטייט של אובייקט משתנה, ה-DOM הווירטואלי משנה רק את האובייקט הזה ב-DOM האמיתי, במקום לעדכן את כל האובייקטים.

## Lifting State Up in React
כשמס' קומפוננטות צריכות לחלוק את הסטייט, מומלץ להרים את הסטייט למעלה בהיררכיה, כדי שיהיה אצל ההורה. במקום לתחזק שני סטייטים בכל ילד.

## styles in React
יש כמה דרכים לסטיילינג בריאקט:
- Inline Styling
- JavaScript Object
- CSS Stylesheet

JavaScript Object:
```jsx harmony
    const divStyle = {
      color: "blue",
      backgroundImage: "url(" + imgUrl + ")",
    };

    function HelloWorldComponent() {
      return <div style={divStyle}>Hello World!</div>;
    }
```

## redux
ספריית קוד פתוח בJS, לעדכון סטייט.
הקומפוננטות שלו כוללות: 
- Store: Holds the state of the application.
- Action: The source information for the store.
- Reducer: Specifies how the application's state changes in response to actions sent to the store.

## React Router
ספריית routing. נועדה לתחזוק טוב ויציב של מבנה הSPA שלנו.  



---
